<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Open-Sessame Framework: Programming Refresher</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Open-Sessame Framework
   &#160;<span id="projectnumber">v1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('ProgrammingRefresher.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Programming Refresher </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Andrew Turner (nilspace)</dd></dl>
<p><a class="el" href="index.html#TableOfContents">Table of Contents</a></p>
<p>Assumedly there are non-programmers, or at least users who may need a refresher on how to code in C++ as well as some small points they may have never covered in their programming experience. This section presents a basic refresher/introduction to some of the programming methods that are used in the Open-Sessame Framework.</p>
<h1><a class="anchor" id="VariableDefs"></a>
Variable Definitions</h1>
<p>Variables are how data is stored and manipulated in a program. Simple enough, you've probably encountered them many times in any number of programming languages. In C++, variables are defined as follows: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> x;          <span class="comment">// defines an integer</span></div>
<div class="line"><span class="keywordtype">double</span> z;       <span class="comment">// defines a double (double-precision float)</span></div>
<div class="line"><span class="keywordtype">float</span> w, r;     <span class="comment">// defines two floats, not great programming practice</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> ii = 0;     <span class="comment">// defines  and initializes an integer</span></div>
</div><!-- fragment --><p>Sometimes, in functions that are called very often, it is useful to define a variable as <em>static</em>. Much of the overhead in computation is allocating and deallocating memory for temporary variables. A static variable has its memory allocated the first time it is called, and the memory is set aside for the variable for the duration of the program. This can greatly speed up operation, as small functions that use large numbers of variables (such as matrices and vectors) must allocate the memory, do a simple computation, and then release the memory. By making the variable static, this allocation and deallocation must only happen once, and subsequent operations are performed in the same memory address. </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">double</span> myArray[10];</div>
</div><!-- fragment --><h1><a class="anchor" id="Classes"></a>
Classes and Objects</h1>
<p>The Open-Sessame framework makes extensive use of the object-oriented nature of C++. A <em>Class</em> is a definition of a new type, like <em>int</em> or <em>string</em>. These objects can be thought of in much the same way we would think of a real world object. A car is an object that has data associated with it: number of wheels and doors, mileage, color, and size, as well as operations that can be done with it: start, stop, go, turn left, turn right, or paint. Data is usually hidden (not directly accessible) to the user, but accessed using operations By encapsulating the data within a class we can change the internal representation without affecting how the user interfaces with the object.</p>
<p>For example, there is a <b>Car</b> class which stores the speed of the car in "Miles Per Hour" (MPH). There is an operation, much like a function, we can call that gives us the speed, <em>GetSpeedMPH()</em>, which returns the speed in miles. However, it is later decided that the speed should internally be stored as Kilometers Per Hour (KPH). The class operation <em>GetSpeedMPH()</em> is internally changed to convert the internal mileage from KPH to MPH, however, an user of the <b>Car</b> class doesn't need to know about this internal change, since the user still calls <em>GetSpeedMPH()</em> and gets the speed of the car in MPH.</p>
<p><b>Terminology</b> </p><ul>
<li><em>Instance:</em> a single instantiation of a class. \tt Car \tt myCar; \tt myCar is an @instance of \tt Car.</li>
<li><em>Member</em> <em>function:</em> a function of a class. \tt Car::GetSpeedMPH()</li>
<li><em>Data</em> <em>member:</em> a variable inside of a class, usually private. \tt Car::m_Speed</li>
<li><em>Template:</em> A type of class that employs a user-specified Class as the variable type in a class. A template class <em>vector&lt;class T&gt;</em> is a vector that holds objects of type <em>T</em>. Therefore, in the code, the user will specify:<div class="fragment"><div class="line">vector&lt;Car&gt; myCarCollection; </div>
</div><!-- fragment --></li>
<li><em>public</em>, <em>protected</em>, <em>private:</em> These are the three levels of access specified for all member functions a data members in a class. <em>Public</em> allows anyone external to the class to call the function or variable. <em>Protected</em> are only accessible to derived classes (discussed below). <em>Private</em> things are accessible only internal to the class.</li>
</ul>
<p>To call member functions of a class, a '.' is used between the instance of the class and the member function call: </p><div class="fragment"><div class="line">Car myCar;</div>
<div class="line">myCar.SetSpeedMPH(55);          <span class="comment">// set the speed of my car to 55 MPH</span></div>
<div class="line">cout &lt;&lt; myCar.GetSpeedKPH();    <span class="comment">// output the speed of the car in KPH to the console</span></div>
</div><!-- fragment --><h2><a class="anchor" id="Inheritance"></a>
Inheritance</h2>
<p>Another important aspect of object-oriented programming is the idea of inheritance. Classes may be <em>derived</em>, which means they are specified to have an "is-a" relationship to the <em>base</em> class. For instance, <b>SportsCar</b> could be a derived class of <b>Car</b>, since "SportsCar is a Car". This allows a programmer to specify general functionality of a car in the <b>Car</b> class, which any type of car would have, while the <b>SportsCar</b> class would implement particular functionality of a sports car such as <em>ShiftGears()</em>, or <em>UseNitro()</em>.</p>
<p>Inheritance is how <em>protected</em> member functions and data members are used. There may be functionality that derived classes should be able to use from a base class, but outside users of the class don't need access to. Continuing the car example, the <b>Car</b> class has a function <em>SetMileage()</em> that all cars have, but shouldn't be accessible by an outside user of the class. However, derived classes, such as <b>SportsCar</b> or <b>StationWagon</b> may need to be able to set the mileage based on their use. Again <em>private</em> member functions and data members are not accessible to derived classes, only to the class in which they are instantiated.</p>
<h2><a class="anchor" id="ADT"></a>
Abstract Data Types</h2>
<p>A special type of base class are <em>Abstract</em> <em>Data</em> <em>Types</em>, ADTs. An ADT is a definition of an interface, but does not include any implementation. Any classes that are derived from the ADT <em>must</em> implement all of the functions defined in the interface of the abstract data type. These functions are called <em>pure</em> @virtual. They are <em>virtual</em> as mentioned above, they can be over-ridden. By being <em>pure</em>, they have no implementation, but specify the user must implement them. Sometimes ADTs are also called <em>base</em> <em>classes</em> for the same reason. An abstract data type can never be instantiated. It is only meant as an inteface.</p>
<p>An example may help illustrate this point. The user could implement a <b>Vehicle</b> abstract data type. This is object-oriented because the user may want to define a general interface to all vehicles, such as <em>Move()</em> <em>Stop()</em>, or even <em>Location()</em>. However, there really isn't anything that is a <em>vehicle</em>. I can't go to a rental agency and say, "I want to rent a vehicle". I have to choose if I want a car, a bicycle, or roller skates. However, all of these vehicles have the common functionality of moving, stopping, or having a location. So instead of worrying if all of the classes have the functionality implemented, or what it's called I can define the functions and name and then make sure (or the code won't compile) each of the derived classes implement these functions.</p>
<h1><a class="anchor" id="Pointers"></a>
Pointers</h1>
<p>Most interfastd::cing with variables is done by actually referring to the object itself. For instance, defining and manipulating an integer: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> myInt = 5;</div>
<div class="line"><span class="keywordtype">int</span> myOtherInt;</div>
<div class="line">myOtherInt = myInt;</div>
<div class="line">myInt = 2;</div>
<div class="line"> </div>
<div class="line">cout &lt;&lt; myInt &lt;&lt; <span class="stringliteral">&quot; != &quot;</span> &lt;&lt; myOtherInt; <span class="comment">// outputs 2 != 5</span></div>
</div><!-- fragment --><p> This is easy to understand and code, and not many worries. However, there are times when a user may just want to refer to the data that will be in the variable, and not the actual value of the variable itself. This is the concept of a pointer. Instead of storing the actual value of the data, you can store a reference to the <em>location</em> of the data, and therefore manipulate or retrieve whatever value may be there, without actually storing a <em>copy</em> of the data itself. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> myInt = 5;</div>
<div class="line"><span class="keywordtype">int</span>* myPointerInt;</div>
<div class="line"> </div>
<div class="line">myPointerInt = &amp;myInt;  <span class="comment">// the &amp; is used to return a reference, or the memory address of myInt</span></div>
<div class="line">myInt = 2;</div>
<div class="line">cout &lt;&lt; myInt &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; *myPointerInt; <span class="comment">// outputs 2 = 2, the * is required to &#39;dereference&#39; the pointer</span></div>
<div class="line">                                         <span class="comment">// and make it act as a normal variable</span></div>
</div><!-- fragment --><p> As you can see, the variable <em>myPointerInt</em> took a <em>reference</em> to <em>myInt</em> (the &amp; returns a reference or the memory address of the variable). Then, by manipulating the variable <em>myInt</em>, I have also manipulated the data where <em>myPointerInt</em> pointed to. This can speed up calculations (such as in functions, where one doesn't need to copy a variable, but just use the data), and also make manipulating internal data easier.</p>
<p>However, the user should be cautioned when using pointers. The user is interacting with the computer's memory which is usually how segmentation faults and other bad things happen (by referenstd::cing unitialized memory, NULL pointers (pointers to 0x0), or the wrong memory address). Another problem is by leaving memory around that is not being used or referenced to. This is commonly known as a <em>memory</em> <em>leak</em>. Refer to your local programming manual for more information. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span>* pMyInt = <span class="keyword">new</span> int;  <span class="comment">// allocate memory (of size int)</span></div>
<div class="line">*pMyInt = 5;            <span class="comment">// Dereference the pointer (use memory space) and assign the value</span></div>
<div class="line"> </div>
<div class="line">pMyInt = NULL;          <span class="comment">// Assign the pointer to NULL (0x0) - WARNING by doing this, we have &#39;lost&#39; </span></div>
<div class="line">                        <span class="comment">// the reference to the allocated int memory, which is now just hogging up </span></div>
<div class="line">                        <span class="comment">// memory space. We should have called &quot;delete pMyInt;&quot; first.</span></div>
</div><!-- fragment --><p>The last 'point' on 'pointers' is how they affect classes and calling member functions. When dealing with a normal class instance, we used a '.' to call a member function. When using a pointer to an instance, instead of having to dereference the pointer, we can just use '-&gt;' to call the member functions: </p><div class="fragment"><div class="line">Car* pMyCar = <span class="keyword">new</span> Car;</div>
<div class="line">pMyCar-&gt;SetSpeedMPH(88.7);</div>
<div class="line">*pMyCar.GetSpeedKPH();          <span class="comment">// this works the same, but isn&#39;t &quot;nice&quot;</span></div>
<div class="line"><span class="keyword">delete</span> pMyCar;                  <span class="comment">// remember to clean up</span></div>
</div><!-- fragment --><h1><a class="anchor" id="Functions"></a>
Functions</h1>
<p>Functions are pretty simple, and similar to most programming languages. The main points include specifying the function name, the return type, and any parameters that are taken into the function. A couple of small points include passing by reference. As mentioned in Pointers, passing a pointer, or reference to data is much faster. Normally, when a variable is just defined as a parameter to a function, a copy is made of the data every time the function is called, which can be rather slow. Therefore, passing by reference can speed this up since just the pointer (an integer) is passed, rather than the whole variable data (which for things like matrices can be quite large).</p>
<p>Furthermore, pass-by-reference allows the user to pass data back out of a function other than just by the return type. This works like pointers and is illustrated below: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> myFunction(<span class="keywordtype">int</span> inputInt, <span class="keywordtype">double</span>&amp; _inputDouble)</div>
<div class="line">{</div>
<div class="line">    _inputDouble = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(inputInt); <span class="comment">// static_cast makes sure to change the </span></div>
<div class="line">                                                 <span class="comment">// value from a type int to a type double</span></div>
<div class="line">    <span class="keywordflow">return</span> inputInt * 5;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="mvasamp1_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">    <span class="keywordtype">double</span> mainDouble = 0;</div>
<div class="line">    cout &lt;&lt; myFunction(5, mainDouble); <span class="comment">// outputs &#39;25&#39;</span></div>
<div class="line">    cout &lt;&lt; mainDouble;                <span class="comment">// outputs &#39;5&#39;</span></div>
<div class="line">}</div>
<div class="ttc" id="amvasamp1_8cpp_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="mvasamp1_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition:</b> <a href="mvasamp1_8cpp_source.html#l00015">mvasamp1.cpp:15</a></div></div>
</div><!-- fragment --><p> When using this function, the user passes in an integer, and a variable that is of type <em>double</em>. The value of this variable will be changed in the calling function too! Remember, this is only for variables passed-by-reference, or by pointer, and <em>not</em> for passed-by-value (the normal way, inputInt). Also, I use an underscore '_' to note which variables are being passed by reference to know in the code that changing the data is propagated back out to the system.</p>
<p>When the user doesn't need to change the variable in a function, it is still better to pass-by-reference. To make sure the variable isn't changed unexpectedly, the variable can be defined <em>const</em>. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> myFunction(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; inputInt, <span class="keywordtype">double</span>&amp; _inputDouble)</div>
<div class="line">{</div>
<div class="line">    _inputDouble = <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(inputInt);  </div>
<div class="line">    <span class="keywordflow">return</span> inputInt * 5;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Therefore, this code works as before, but passes a <em>const-reference</em> to the variable <em>inputInt</em>, which doesn't affect its usage in the function anyway, but can speed up operation.</p>
<h2><a class="anchor" id="CallbackFunctions"></a>
Call-back Functions</h2>
<p>Sometimes it is useful to pass around references to function, much like pointers, rather than have to hardcode in a function call. This is why <em>call-back</em> <em>functions</em>, or <em>function</em> <em>references</em> are used. The user can store a variable that refers to a function, and can be changed at any point. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> myFunc1(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; inputVar); <span class="comment">// just a prototype, but it is defined elsewhere</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> myFunc2(<span class="keyword">const</span> <span class="keywordtype">int</span>&amp; inputVar);</div>
<div class="line"> </div>
<div class="line">int (*intFuncPtr)(int);          <span class="comment">// definition of the function pointer</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="mvasamp1_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div>
<div class="line">        intFuncPtr = &amp;myFunc1;   <span class="comment">// Assign the function pointer to the first function</span></div>
<div class="line">        cout &lt;&lt; intFuncPtr(5);</div>
<div class="line">        </div>
<div class="line">        intFuncPtr = &amp;myFunc2;   </div>
<div class="line">        cout &lt;&lt; intFuncPtr(5);   <span class="comment">// Same call as above, but now calls function 2</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="Functors"></a>
Functors</h2>
<p><em>Functors</em> are a type of function reference, but they can point to member functions of classes. Therefore, to initialize, they require an instance of an object as well as the member function reference. </p><div class="fragment"><div class="line">ObjectFunctor myObjFunc(myCar, &amp;Car::GetSpeedMPH); </div>
</div><!-- fragment --><h1><a class="anchor" id="MatrixVector"></a>
Matrix and Vector classes</h1>
<p>The Open-Sessame framework uses an open-source matrix and vector class library. Documentation can currently be read from the <a href="http://sourceforge.net/projects/spacecraft" target="_new">Open-Sessame sourceforge site</a> under the "Docs" link.</p>
<h1><a class="anchor" id="UML"></a>
UML Diagrams</h1>
<p>In order to document and describe object-oriented designs, inheritance and classes, the Unified Modeling Language (UML) can be used. This is a specification for diagramming classes, functions, packages, and any other coding artifact.</p>
<p>Shown below is an example UML class diagram describing the example classes of vehicles and cars described above. </p><div class="image">
<img src="ExampleUML.jpg" alt=""/>
</div>
<p>Each box is a class, with the name of the class shown in the top box. The next section of a 3-paned class box shows the attributes, or private data members, of the class. The "-" (minus) symbol shows that the visibility is <em>private</em>. The last box of a 3-paned class is the list of member functions, or operations. Again, "-" denotes <em>private</em>, "+" denotes <em>public</em>, and "#" denotes <em>protected</em>.</p>
<p>Inheritance is shown using open arrows in the middle of lines between classes. The arrow points towards the base class. Therefore, <b>Car</b> is derived from <b>Vehicle</b>. Also note that <b>Vehicle</b> is in italics, which means that it is abstract (ADT). Futhermore, the member functions are in italics denoting that they are pure virtual.</p>
<p>Lastly, aggregation, or composition of classes, is shown using diamonds and arrows. This is saying that the class with the diamond "has-a" class where the arrow points to. Furthermore, the number of instances are shown with the numbers (1..n being atleast 1 up to any number, or "1,2" denoting 1 or 2 elements). From the example, a <b>Car</b> can have 1 to however many <b>Axles</b>, which have 1 or 2 <b>Wheels</b>.</p>
<p>Other UML diagrams demonstrate "Use Cases", "State Diagrams", "Activity Diagrams", or "Event Traces". Refer to a UML book or style guide for more information. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
